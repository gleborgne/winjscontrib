<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>WinJS Contrib Source: winjscontrib.ui.navigator.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	
	<link type="text/css" rel="stylesheet" href="styles/site.cosmo.css">
	
</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top ">
		<div class="navbar-inner">
			<a class="brand" href="index.html">WinJS Contrib</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#WinJSContrib">WinJSContrib</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Alerts.html">Alerts</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Bindings.html">Bindings</a>
						</li>
						
						<li>
							<a href="WinJSContrib.CrossPlatform.html">CrossPlatform</a>
						</li>
						
						<li>
							<a href="WinJSContrib.CrossPlatform.isMobile.html">isMobile</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Logging.html">Logging</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Logging.Appenders.html">Appenders</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.html">Search</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.Stemming.html">Stemming</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.Stemming.Op.html">Op</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.Stemming.StopWords.html">StopWords</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Templates.html">Templates</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.html">UI</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.Animation.html">Animation</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.DataForm.Converters.html">Converters</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.DataForm.defaultBindingOptions.html">defaultBindingOptions</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.DataSources.html">DataSources</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.DataSources.Grouping.html">Grouping</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.WebComponents.html">WebComponents</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Utils.html">Utils</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Utils.ValueParsers.html">ValueParsers</a>
						</li>
						
						<li>
							<a href="WinJSContrib.WinRT.html">WinRT</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="WinJSContrib.Logging.Appenders.ConsoleAppender.html">ConsoleAppender</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Logging.LoggerClass.html">LoggerClass</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Messenger.html">Messenger</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Messenger.SmartWorker.html">SmartWorker</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.Index.html">Index</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.IndexGroup.html">IndexGroup</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.IndexWorkerProxy.html">IndexWorkerProxy</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.Stemming.Pipeline.html">Pipeline</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.ChildViewFlyout.html">ChildViewFlyout</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.DataForm.html">DataForm</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.DataSources.DataSourceManager.html">DataSourceManager</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.ElasticInput.html">ElasticInput</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.EventTracker.html">EventTracker</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.ExtendedSplash.html">ExtendedSplash</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.FlipSnap.html">FlipSnap</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.FlipViewPager.html">FlipViewPager</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.FluentDOM.html">FluentDOM</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.FlyoutPage.html">FlyoutPage</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.GlobalProgress.html">GlobalProgress</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.GridControl.html">GridControl</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.HubControl.html">HubControl</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.MediaTrigger.html">MediaTrigger</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.MultiPassItem.html">MultiPassItem</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.MultiPassRenderer.html">MultiPassRenderer</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.PageControlNavigator.html">PageControlNavigator</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.SemanticListViews.html">SemanticListViews</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.SmartListLayout.html">SmartListLayout</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UPnP.UPnPDevice.html">UPnPDevice</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: winjscontrib.ui.navigator.js</h1>
    
    <section>
        <article>
            <pre class="sunlight-highlight-javascript linenums">/* 
 * WinJS Contrib v2.1.0.2
 * licensed under MIT license (see http://opensource.org/licenses/MIT)
 * sources available at https://github.com/gleborgne/winjscontrib
 */

/// &lt;reference path="WinJSContrib.core.js" />

(function () {
    "use strict";

    var appView = null;
    if (window.Windows &amp;&amp; window.Windows.UI &amp;&amp; window.Windows.UI.ViewManagement &amp;&amp; window.Windows.UI.ViewManagement.ApplicationView)
        appView = window.Windows.UI.ViewManagement.ApplicationView;

    var nav = WinJS.Navigation;

    var defaultExitPageAnimation = function (elt) {
        return WinJS.UI.Animation.exitPage(elt)
    }

    var defaultEnterPageAnimation = function (elt) {
        return WinJS.UI.Animation.enterPage(elt);
    }

    WinJS.Namespace.define("WinJSContrib.UI", {
        parentNavigator: function (element) {
            var current = element.parentNode;

            while (current) {
                if (current.mcnNavigator) {
                    return current.winControl;
                }
                current = current.parentNode;
            }
        },

        PageControlNavigator: WinJS.Class.mix(WinJS.Class.define(
            /**
             * @class WinJSContrib.UI.PageControlNavigator
             * @param {HTMLElement} element DOM element containing the control
             * @param {Object} options
             */
            function PageControlNavigator(element, options) {
                var options = options || {};
                var navigator = this;
                this.element = element || document.createElement("div");
                this.element.winControl = this;
                this.element.mcnNavigator = true;
                this.element.classList.add('mcn-navigator');
                this.element.classList.add('mcn-navigation-ctrl');
                this.eventTracker = new WinJSContrib.UI.EventTracker();
                this.delay = options.delay || 0;
                this.disableHistory = options.disableHistory || false;
                this.animationWaitForPreviousPageClose = options.animationWaitForPreviousPageClose || true;
                this.animations = {};
                this.locks = 0;

                if (options.enterPageAnimation) {
                    this.animations.enterPage = WinJSContrib.Utils.resolveMethod(element, options.enterPageAnimation);
                }
                if (!this.animations.enterPage)
                    this.animations.enterPage = defaultEnterPageAnimation;

                if (options.exitPageAnimation) {
                    this.animations.exitPage = WinJSContrib.Utils.resolveMethod(element, options.exitPageAnimation);
                }
                if (!this.animations.exitPage)
                    this.animations.exitPage = defaultExitPageAnimation;
                this.home = options.home;
                if (appView)
                    this._lastViewstate = appView.value;

                this.global = options.global !== undefined ? options.global : true;
                if (this.global) { //navigation classique 
                    document.body.onkeyup = this._keyupHandler.bind(this);
                    document.body.onkeypress = this._keypressHandler.bind(this);
                    document.body.onmspointerup = this._mspointerupHandler.bind(this);

                    WinJSContrib.UI.Application = WinJSContrib.UI.Application || {};
                    WinJSContrib.UI.Application.navigator = this;

                    this.eventTracker.addEvent(nav, 'beforenavigate', this._beforeNavigate.bind(this));
                    this.eventTracker.addEvent(nav, 'navigated', this._navigated.bind(this));

                    var systemNavigationManager = null;
                    if (WinJSContrib.UI.enableSystemBackButton &amp;&amp; window.Windows &amp;&amp; window.Windows.UI &amp;&amp; window.Windows.UI.Core &amp;&amp; window.Windows.UI.Core.SystemNavigationManager) {
                        systemNavigationManager = window.Windows.UI.Core.SystemNavigationManager.getForCurrentView();
                    }

                    if (systemNavigationManager &amp;&amp; WinJSContrib.UI.enableSystemBackButton) {
                        this.eventTracker.addEvent(systemNavigationManager, 'backrequested', function (arg) {
                            if (WinJS.Navigation.canGoBack) {
                                WinJS.Navigation.back();
                                arg.handled = true;
                            }
                        });

                    }
                }
                else {
                    if (options.navigationEvents) {
                        this.addNavigationEvents();
                    }
                    this._history = { backstack: [] };
                }

                this.eventTracker.addEvent(window, 'resize', function (args) {
                    if (navigator.resizeHandler)
                        cancelAnimationFrame(navigator.resizeHandler);

                    navigator.resizeHandler = requestAnimationFrame(function () {
                        navigator.resizeHandler = null;
                        navigator._resized(args);
                    });
                });
            },
                /**
                 * @lends WinJSContrib.UI.PageControlNavigator.prototype
                 */
                {
                    home: "",
                    /// &lt;field domElement="true" />
                    element: null,
                    _lastNavigationPromise: WinJS.Promise.as(),
                    _lastViewstate: 0,

                    // This is the currently loaded Page object.
                    pageControl: {
                        get: function () {
                            return this.pageElement ? this.pageElement.winControl : null;
                        }
                    },

                    // This is the root element of the current page.
                    pageElement: {
                        get: function () {
                            return this._pageElement || this.element.lastElementChild;
                        }
                    },

                    history: {
                        get: function () {
                            if (this.global)
                                return WinJS.Navigation.history;
                            else
                                return this._history;
                        }
                    },

                    addLock: function () {
                        this.locks++;
                    },

                    removeLock: function () {
                        this.locks--;
                    },

                    // Creates a container for a new page to be loaded into.
                    _createPageElement: function () {
                        var element = document.createElement("div");
                        element.setAttribute("dir", window.getComputedStyle(this.element, null).direction);
                        //element.style.width = "100%";
                        //element.style.height = "100%";
                        //element.style.position = 'relative';
                        return element;
                    },

                    // This function disposes the page navigator and its contents.
                    dispose: function () {
                        if (this._disposed) {
                            return;
                        }
                        this._disposed = true;
                        this.removeNavigationEvents();
                        if (WinJS.Utilities.disposeSubTree)
                            WinJS.Utilities.disposeSubTree(this.element);

                        this.eventTracker.dispose();
                    },

                    //check back navigation in the context of navigation events.
                    _checkBackNavigation: function (arg) {
                        var navigator = this;
                        var currentPage = navigator.pageControl;
                        var confirm = function () {
                            arg.handled = true;
                            if (arg.preventDefault)
                                arg.preventDefault();
                        }
                        var check = function () {
                            if (navigator.canGoBack) {
                                navigator.back();
                                confirm();
                                return true;
                            };
                        }

                        if (currentPage.canClose) {
                            var res = currentPage.canClose();
                            if (WinJS.Promise.is(res)) {
                                res.then(function (canClose) {
                                    if (!canClose) {
                                        confirm();
                                        return true;
                                    }
                                    return check();
                                });
                            } else {
                                if (!res) {
                                    confirm();
                                    return true;
                                }
                                return check();
                            }

                        } else {
                            return check();
                        }
                    },

                    //register hardware backbutton. unecessary if navigator is global
                    addNavigationEvents: function () {
                        var navigator = this;
                        this.navigationEvents = WinJSContrib.UI.registerNavigationEvents(this, function (arg) {
                            navigator._checkBackNavigation(arg);
                        });
                    },

                    removeNavigationEvents: function () {
                        if (this.navigationEvents) {
                            this.navigationEvents();
                            this.navigationEvents = null;
                        }
                    },

                    // Retrieves a list of animation elements for the current page.
                    // If the page does not define a list, animate the entire page.
                    _getAnimationElements: function (isExit) {
                        if (this.pageControl &amp;&amp; this.pageControl.getAnimationElements) {
                            return this.pageControl.getAnimationElements(isExit);
                        }
                        return this.pageElement;
                    },

                    // Navigates back whenever the backspace key is pressed and
                    // not captured by an input field.
                    _keypressHandler: function (args) {
                        if (this.locks > 0)
                            return;

                        if (args.key === "Backspace") {
                            this.back();
                        }
                    },

                    // Navigates back or forward when alt + left or alt + right
                    // key combinations are pressed.
                    _keyupHandler: function (args) {
                        if (this.locks > 0)
                            return;

                        if ((args.key === "Left" &amp;&amp; args.altKey) || (args.key === "BrowserBack")) {
                            this.back();
                        }/* else if ((args.key === "Right" &amp;&amp; args.altKey) || (args.key === "BrowserForward")) {
            			nav.forward();
            		}*/
                    },

                    // This function responds to clicks to enable navigation using
                    // back and forward mouse buttons.
                    _mspointerupHandler: function (args) {
                        if (args.button === 3) {
                            nav.back();
                        } else if (args.button === 4) {
                            nav.forward();
                        }
                    },

                    navigate: function (location, initialState, skipHistory, isback) {
                        var nav = this;
                        if (this.global) {
                            return WinJS.Navigation.navigate(location, initialState);
                        } else {
                            var arg = {
                                skipHistory: skipHistory,
                                detail: {
                                    location: location,
                                    state: initialState,
                                    setPromise: function (promise) {
                                        this.pagePromise = promise;
                                    }
                                }
                            };
                            nav._beforeNavigate(arg);
                            arg.detail.pagePromise = arg.detail.pagePromise || WinJS.Promise.wrap();
                            nav._history.current = { state: initialState, location: location };
                            return arg.detail.pagePromise.then(function () {
                                if (isback) {
                                    nav._history.backstack.splice(nav._history.backstack.length - 1, 1);
                                }
                                nav._navigated(arg);
                                return arg.detail.pagePromise;
                            });
                        }
                    },

                    clearHistory: function () {
                        if (this.global) {
                            WinJS.Navigation.history.backStack = [];
                        } else {
                            this._history.backstack = [];
                            this._history.current = null;
                        }
                    },

                    closeAllPages: function () {
                        var navigator = this;
                        var pages = navigator.element.querySelectorAll('.pagecontrol');
                        for (var i = 0, l = pages.length ; i &lt; l ; i++) {
                            var page = pages[i];
                            if (page.parentElement == navigator.element) {
                                page.winControl.dispose();
                                navigator.element.removeChild(page);
                            }
                        }
                    },

                    clear: function () {
                        this.clearHistory();
                        this.closeAllPages();
                        this._pageElement = null;
                        this.element.innerHTML = '';
                    },

                    //warning, deprecated...
                    open: function (uri, options) {
                        return this.navigate(uri, options);
                    },

                    pick: function (uri, options) {
                        options = options || {};
                        options.navigateStacked = true;
                        return this.navigate(uri, options);
                    },

                    canGoBack: {
                        get: function () {
                            if (this.global)
                                return nav.canGoBack;
                            else
                                return this._history.backstack.length > 0;
                        }
                    },

                    back: function (distance) {
                        var navigator = this;
                        if (navigator.global) {
                            return WinJS.Navigation.back(distance);
                        }
                        else {
                            if (navigator._history.backstack.length) {
                                var pageindex = navigator._history.backstack.length - 1;
                                var previousPage = navigator._history.backstack[pageindex];

                                return navigator.navigate(previousPage.location, previousPage.state, true, true);
                            }
                        }
                    },

                    _beforeNavigate: function (args) {
                        var navigator = this;
                        var page = this.pageElement;
                        args.detail.state = args.detail.state || {};
                        var openStacked = navigator.stackNavigation == true || args.detail.state.navigateStacked;

                        if (this.locks > 0) {
                            var p = new WinJS.Promise(function (c) { });
                            args.detail.setPromise(p);
                            p.cancel();
                            return;
                        }
                        else if (page &amp;&amp; page.winControl &amp;&amp; page.winControl.canClose) {
                            var completeCallback = null;
                            var p = new WinJS.Promise(function (c) {
                                completeCallback = c;
                            });
                            setImmediate(function () {
                                WinJS.Promise.wrap(page.winControl.canClose()).then(function (res) {
                                    if (!res) {
                                        p.cancel();
                                    }
                                    else {
                                        navigator.triggerPageExit();
                                        completeCallback();
                                    }
                                });
                            });
                            args.detail.setPromise(p);

                            return;
                        }

                        if (openStacked &amp;&amp; !args.detail.state.mcnNavigationDetails)
                            return;

                        navigator.triggerPageExit();
                    },

                    triggerPageExit: function () {
                        var navigator = this;
                        var page = this.pageElement;
                        var hidepage = function () {
                            page.style.display = 'none';
                            page.style.visibility = 'hidden';
                            page.style.opacity = '';
                        }
                        if (page &amp;&amp; page.winControl &amp;&amp; !page.winControl.exitPagePromise) {
                            if (page.winControl.exitPage) {
                                var exitPageResult = page.winControl.exitPage();
                                if (exitPageResult) {
                                    var res = WinJS.Promise.as(exitPageResult);
                                    page.winControl.exitPagePromise = res.then(function () {
                                        if (page.winControl.exitPageAnimation) {
                                            return WinJS.Promise.as(page.winControl.exitPageAnimation());
                                        }
                                    }).then(hidepage);
                                } else {
                                    if (page.winControl.exitPageAnimation) {
                                        page.winControl.exitPagePromise = WinJS.Promise.as(page.winControl.exitPageAnimation()).then(hidepage);
                                    } else {
                                        page.winControl.exitPagePromise = WinJS.Promise.as(navigator.animations.exitPage(navigator._getAnimationElements(true))).then(hidepage);
                                    }
                                }
                            } else {
                                if (page.winControl.exitPageAnimation) {
                                    page.winControl.exitPagePromise = WinJS.Promise.as(page.winControl.exitPageAnimation()).then(hidepage);
                                } else {
                                    page.winControl.exitPagePromise = WinJS.Promise.as(navigator.animations.exitPage(navigator._getAnimationElements(true))).then(hidepage);
                                }
                            }

                            var layoutCtrls = page.querySelectorAll('.mcn-layout-ctrl');
                            if (layoutCtrls &amp;&amp; layoutCtrls.length) {
                                for (var i = 0 ; i &lt; layoutCtrls.length; i++) {
                                    var ctrl = layoutCtrls[i].winControl;
                                    if (ctrl.exitPage)
                                        ctrl.exitPage();
                                }
                            }

                            if (WinJSContrib.UI.Application.progress)
                                WinJSContrib.UI.Application.progress.show();
                        }
                    },

                    closePage: function (pageElementToClose, args) {
                        var navigator = this;
                        args = args || {};
                        var pagecontainer = navigator.element;
                        var oldElement = pageElementToClose || this.pageElement;
                        if (oldElement) {
                            WinJSContrib.UI.untapAll(oldElement);
                        }
                        var oldPageExitPromise = (oldElement &amp;&amp; oldElement.winControl &amp;&amp; oldElement.winControl.exitPagePromise) ? oldElement.winControl.exitPagePromise : WinJS.Promise.wrap()
                        navigator.dispatchEvent('closingPage', { page: oldElement });

                        if (oldElement &amp;&amp; oldElement.winControl) {
                            oldElement.winControl.pageLifeCycle.stop();
                            oldElement.winControl.dispatchEvent('closing', { youpla: 'boom' });

                            if (oldElement.winControl.cancelPromises) {
                                oldElement.winControl.cancelPromises();
                            }
                        }

                        if (!navigator.global &amp;&amp; !navigator.disableHistory &amp;&amp; oldElement &amp;&amp; oldElement.winControl &amp;&amp; oldElement.winControl.navigationState &amp;&amp; !args.skipHistory) {
                            navigator._history.backstack.push(oldElement.winControl.navigationState);
                        }

                        navigator._pageElement = null;
                        return oldPageExitPromise.then(function () {
                            if (oldElement) {
                                oldElement.style.opacity = '0';
                                oldElement.style.display = 'none';
                                //    }
                                //    return WinJS.Promise.timeout();
                                //}).then(function () {
                                //    if (oldElement) {
                                if (oldElement.winControl) {
                                    oldElement.winControl.stackedOn = null;
                                    oldElement.winControl.stackedBy = null;
                                    if (oldElement.winControl.eventTracker) {
                                        oldElement.winControl.eventTracker.dispose();
                                    }

                                    if (oldElement.winControl.unload) {
                                        oldElement.winControl.unload();
                                    }
                                }

                                if (WinJS.Utilities.disposeSubTree)
                                    WinJS.Utilities.disposeSubTree(oldElement);

                                //oldElement.innerHTML = '';
                                //setImmediate(function () {
                                try {
                                    oldElement.parentElement.removeChild(oldElement);
                                }
                                catch (exception) {
                                    console.log('cannot remove page, WTF ????????')
                                }
                                //});
                            }
                        });
                    },

                    // Responds to navigation by adding new pages to the DOM.
                    _navigated: function (args) {
                        var navigator = this;
                        var systemNavigationManager = null;
                        if (WinJSContrib.UI.enableSystemBackButton &amp;&amp; window.Windows &amp;&amp; window.Windows.UI &amp;&amp; window.Windows.UI.Core &amp;&amp; window.Windows.UI.Core.SystemNavigationManager) {
                            systemNavigationManager = window.Windows.UI.Core.SystemNavigationManager.getForCurrentView();
                        }
                        if (navigator.global &amp;&amp; systemNavigationManager &amp;&amp; WinJSContrib.UI.enableSystemBackButton) {
                            if (!WinJS.Navigation.canGoBack)
                                systemNavigationManager.appViewBackButtonVisibility = window.Windows.UI.Core.AppViewBackButtonVisibility.collapsed;
                            else
                                systemNavigationManager.appViewBackButtonVisibility = window.Windows.UI.Core.AppViewBackButtonVisibility.visible;
                        }

                        args.detail.state = args.detail.state || {};
                        var pagecontainer = navigator.element;
                        var oldPage = this.pageControl;
                        var oldElement = this.pageElement;
                        var openStacked = navigator.stackNavigation == true || (args.detail.state &amp;&amp; args.detail.state.navigateStacked);

                        if (this._lastNavigationPromise) {
                            this._lastNavigationPromise.cancel();

                            if (WinJSContrib.UI.Application.progress)
                                WinJSContrib.UI.Application.progress.hide();
                        }

                        if (oldPage &amp;&amp; oldPage.stackedOn &amp;&amp; args.detail.state.mcnNavigationDetails) {//back en nav stacked
                            var closeOldPagePromise = navigator.closePage(oldElement, args);
                            this._lastNavigationPromise = closeOldPagePromise;
                            args.detail.setPromise(closeOldPagePromise);
                            if (WinJSContrib.UI.Application.progress)
                                WinJSContrib.UI.Application.progress.hide();
                            return;
                        }
                        else if (openStacked) {
                            if (!navigator.global &amp;&amp; !navigator.disableHistory &amp;&amp; oldElement &amp;&amp; oldElement.winControl &amp;&amp; oldElement.winControl.navigationState &amp;&amp; !args.skipHistory) {
                                navigator._history.backstack.push(oldElement.winControl.navigationState);
                            }
                            var closeOldPagePromise = WinJS.Promise.wrap();
                        }
                        else {
                            var closeOldPagePromise = navigator.closePage(oldElement, args);
                        }
                        //if (this._handleSystemBackBtn &amp;&amp; Windows &amp;&amp; Windows.UI &amp;&amp; Windows.UI.Core &amp;&amp; Windows.UI.Core.SystemNavigationManager) {
                        //    if (navigator.canGoBack)
                        //        Windows.UI.Core.SystemNavigationManager.getForCurrentView().appViewBackButtonVisibility = Windows.UI.Core.AppViewBackButtonVisibility.visible;
                        //    else
                        //        Windows.UI.Core.SystemNavigationManager.getForCurrentView().appViewBackButtonVisibility = Windows.UI.Core.AppViewBackButtonVisibility.collapsed;
                        //}
                        args.detail.state.mcnNavigationDetails = {
                            id: WinJSContrib.Utils.guid(),
                            date: new Date()
                        };

                        //var newElement = null; //this._createPageElement();
                        //var newElementCtrl = null;
                        var parentedComplete;
                        var parented = new WinJS.Promise(function (c) { parentedComplete = c; });
                        //newElement.style.opacity = '0';
                        var layoutCtrls = [];


                        //if (navigator.animationWaitForPreviousPageClose) {
                        //    var tempo = closeOldPagePromise.then(function () {
                        //        return WinJS.Promise.timeout(navigator.delay);
                        //    });
                        //} else {
                        //    var tempo = WinJS.Promise.timeout(navigator.delay);
                        //}

                        navigator.currentPageDetails = args.detail;

                        var openNewPagePromise = WinJSContrib.UI.Pages.renderFragment(pagecontainer, args.detail.location, args.detail.state, {
                            //delay: tempo,
                            enterPage: navigator.animations.enterPage,

                            //parented: closeOldPagePromise.then(function () {
                            //	return parented;
                            //}),

                            closeOldPagePromise: closeOldPagePromise.then(function () { }, function () { }),

                            oninit: function (element, options) {
                                if (!element) return;
                                var control = element.winControl;
                                control.navigator = navigator;
                                control.element.mcnPage = true;
                                if (openStacked) {
                                    control.stackedOn = oldPage;
                                    if (oldPage) {
                                        oldPage.stackedBy = control;
                                    }
                                }
                                control.renderComplete = control.renderComplete.then(function () {
                                    parentedComplete();
                                });
                            },

                            onrender: function (element, options) {
                                if (args.detail.state &amp;&amp; args.detail.state.clearNavigationHistory) {
                                    if (navigator.global) {
                                        WinJS.Navigation.history.backStack = [];
                                    } else {
                                        navigator._history.backstack = [];
                                    }
                                }
                                navigator._updateBackButton(element);
                            },

                            onready: function (element, options) {
                                navigator.dispatchEvent('pageContentReady', { page: element.winControl });
                                if (WinJSContrib.UI.Application.progress)
                                    WinJSContrib.UI.Application.progress.hide();
                            }
                        }).then(function () {
                            navigator._lastNavigationPromise = undefined;
                        });

                        this._lastNavigationPromise = openNewPagePromise;


                        args.detail.setPromise(WinJS.Promise.join([closeOldPagePromise, openNewPagePromise]));
                    },

                    // Responds to resize events and call the updateLayout function
                    // on the currently loaded page.
                    _resized: function (args) {
                        var navigator = this;
                        if (this.pageControl &amp;&amp; this.pageControl.element) {
                            var navigator = this;
                            var control = this.pageControl;
                            var element = control.element;

                            //navigator.pageControl.element.opacity = '0';
                            cancelAnimationFrame(navigator.layoutProcess);
                            navigator.layoutProcess = requestAnimationFrame(function () {
                                var vw = appView ? appView.value : null;
                                if (control.__checkLayout) {
                                    control.__checkLayout(element, vw, navigator._lastViewstate);
                                }
                                else {
                                    if (control.updateLayout) {
                                        control.updateLayout.call(control, element, vw, navigator._lastViewstate);
                                    }
                                    var layoutCtrls = element.element.querySelectorAll('.mcn-layout-ctrl');
                                    if (layoutCtrls &amp;&amp; layoutCtrls.length) {
                                        for (var i = 0 ; i &lt; layoutCtrls.length; i++) {
                                            var ctrl = layoutCtrls[i].winControl;
                                            if (ctrl.updateLayout)
                                                ctrl.updateLayout(ctrl.element, vw, navigator._lastViewstate);
                                        }
                                    }
                                }
                                //WinJS.UI.Animation.fadeIn(navigator.pageControl.element);
                            });
                        }
                        this._lastViewstate = appView ? appView.value : null;
                    },

                    _handleBack: function () {
                        nav.back();
                    },

                    // Updates the back button state. Called after navigation has
                    // completed.
                    _updateBackButton: function (element) {
                        var ctrl = this;
                        var backButtons = element.querySelectorAll(".win-backbutton, .back-button, .win-navigation-backbutton");
                        //var backButton = this.pageElement.querySelector("header[role=banner] .win-backbutton");

                        if (backButtons &amp;&amp; backButtons.length > 0) {
                            var clearNav = false;
                            //console.log('nav:' + JSON.stringify(args.detail.state))
                            //if (args &amp;&amp; args.detail &amp;&amp; args.detail.state &amp;&amp; args.detail.state.clearNavigationHistory)
                            //    clearNav = args.detail.state.clearNavigationHistory;

                            for (var i = 0, l = backButtons.length; i &lt; l ; i++) {
                                var btn = backButtons[i];
                                if (ctrl.canGoBack &amp;&amp; !clearNav) {
                                    btn.classList.remove('disabled');
                                    btn.disabled = false;
                                } else {
                                    btn.classList.add('disabled');
                                    btn.disabled = true;
                                }

                                btn.onclick = function (arg) {
                                    if (ctrl.global) {
                                        nav.back();
                                    }
                                    else {
                                        var navigator = WinJSContrib.UI.parentNavigator(arg.currentTarget);
                                        navigator.back();
                                    }
                                }
                            }
                        }
                    }
                }
            ), WinJS.Utilities.eventMixin)
    });

    if (WinJSContrib.UI.WebComponents) {
        WinJSContrib.UI.WebComponents.register('mcn-navigator', WinJSContrib.UI.PageControlNavigator, {
            properties: ['global'],
            map: {
                "ENTERPAGEANIMATION": {
                    attribute: "enterPageAnimation",
                    property: "animations.enterPage",
                    resolve: true
                },
                "EXITPAGEANIMATION": {
                    attribute: "exitPageAnimation",
                    property: "animations.exitPage",
                    resolve: true
                }
            }
        });
    }
})();
</pre>
        </article>
    </section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					by MCNEXT
					<br />
					
					
		<span class="copyright">
		copyright MCNEXT
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a>
		on Tue Jul 07 2015 09:14:15 GMT+0200 (Paris, Madrid (heure d’été)) using the <a href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<script src="scripts/sunlight.js"></script>
	<script src="scripts/sunlight.javascript.js"></script>
	<script src="scripts/sunlight-plugin.doclinks.js"></script>
	<script src="scripts/sunlight-plugin.linenumbers.js"></script>
	<script src="scripts/sunlight-plugin.menu.js"></script>
	<script src="scripts/jquery.min.js"></script>
	<script src="scripts/jquery.scrollTo.js"></script>
	<script src="scripts/jquery.localScroll.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>


	<script>  Sunlight.highlightAll({lineNumbers:true,  showMenu: true, enableDoclinks :true}); </script>

	<script>
		$( function () {
			$( "#toc" ).toc( {
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : 60
			} );
			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );

		} );
	</script>

	

</body>
</html>
